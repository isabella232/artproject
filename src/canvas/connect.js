var Ops=Ops||{};Ops.Gl=Ops.Gl||{},Ops.Math=Ops.Math||{},Ops.Anim=Ops.Anim||{},Ops.Trigger=Ops.Trigger||{},Ops.Gl.Shader=Ops.Gl.Shader||{},Ops.Gl.Meshes=Ops.Gl.Meshes||{},Ops.Gl.Matrix=Ops.Gl.Matrix||{},Ops.Deprecated=Ops.Deprecated||{},Ops.Gl.ShaderEffects=Ops.Gl.ShaderEffects||{},Ops.Gl.TextureEffects=Ops.Gl.TextureEffects||{},Ops.Gl.TextureEffects.Noise=Ops.Gl.TextureEffects.Noise||{},Ops.Trigger.Sequence=function(){Op.apply(this,arguments);var e=this,t=e.addInPort(new Port(e,"exe",OP_PORT_TYPE_FUNCTION)),n=[],r=[],o=function(){for(var e=0;e<r.length;e++)r[e].trigger()};t.onTriggered=o;for(var i=16,a=0;i>a;a++)if(r.push(e.addOutPort(new Port(e,"trigger "+a,OP_PORT_TYPE_FUNCTION))),i-1>a){var l=e.addInPort(new Port(e,"exe "+a,OP_PORT_TYPE_FUNCTION));l.onTriggered=o,n.push(l)}},Ops.Trigger.Sequence.prototype=new CABLES.Op,Ops.Gl.TextureEffects.ImageCompose=function(){function e(){P&&P["delete"](),T&&T["delete"](),P=new CGL.TextureEffect(p,{isFloatingPointTexture:g.get()}),T=new CGL.Texture(p,{isFloatingPointTexture:g.get(),filter:L,wrap:w,width:Math.floor(s.get()),height:Math.floor(d.get())}),P.setSourceTexture(T),_.set(null),O=!1}function t(){P||e(),l.get()?(m=p.getViewPort()[2],v=p.getViewPort()[3]):(m=Math.floor(s.get()),v=Math.floor(d.get())),m==T.width&&v==T.height||0===m||0===v||(d.set(v),s.set(m),T.filter=CGL.Texture.FILTER_LINEAR,T.setSize(m,v),x.set(m/v),P.setSourceTexture(T)),_.get()&&(_.get().isPowerOfTwo()?i.uiAttribs.hint&&i.uiAttr({hint:null,warning:null}):i.uiAttribs.hint||i.uiAttr({hint:"texture dimensions not power of two! - texture filtering will not work.",warning:null}))}function n(){l.get()?(s.setUiAttribs({hidePort:!0,greyout:!0}),d.setUiAttribs({hidePort:!0,greyout:!0})):(s.setUiAttribs({hidePort:!1,greyout:!1}),d.setUiAttribs({hidePort:!1,greyout:!1}))}function r(){"repeat"==c.get()&&(w=CGL.Texture.WRAP_REPEAT),"mirrored repeat"==c.get()&&(w=CGL.Texture.WRAP_MIRRORED_REPEAT),"clamp to edge"==c.get()&&(w=CGL.Texture.WRAP_CLAMP_TO_EDGE),O=!0,t()}function o(){"nearest"==u.get()&&(L=CGL.Texture.FILTER_NEAREST),"linear"==u.get()&&(L=CGL.Texture.FILTER_LINEAR),O=!0,t()}Op.apply(this,arguments);var i=this,a=i.addInPort(new Port(i,"render",OP_PORT_TYPE_FUNCTION)),l=i.addInPort(new Port(i,"use viewport size",OP_PORT_TYPE_VALUE,{display:"bool"})),s=i.inValueInt("width"),d=i.inValueInt("height"),u=i.inValueSelect("filter",["nearest","linear","mipmap"]),c=i.inValueSelect("wrap",["clamp to edge","repeat","mirrored repeat"]),f=i.inValueSlider("Background Alpha",1),g=i.inValueBool("HDR"),h=i.addOutPort(new Port(i,"trigger",OP_PORT_TYPE_FUNCTION)),_=i.outTexture("texture_out"),x=i.outValue("Aspect Ratio");_.set(null);var p=i.patch.cgl,P=null,T=null,m=8,v=8,E=[0,0,0,0],O=!0,C="".endl()+"precision highp float;".endl()+"uniform float a;".endl()+"void main()".endl()+"{".endl()+"   gl_FragColor = vec4(0.0,0.0,0.0,a);".endl()+"}",y=new CGL.Shader(p,"imgcompose bg");y.setSource(y.getDefaultVertexShader(),C);var L=(new CGL.Uniform(y,"f","a",f),CGL.Texture.FILTER_LINEAR),w=CGL.Texture.WRAP_CLAMP_TO_EDGE;g.onChange=function(){O=!0},l.onValueChanged=function(){n(),l.get()?(s.onValueChanged=null,d.onValueChanged=null):(s.onValueChanged=t,d.onValueChanged=t),t()};var R=function(){(!P||O)&&e();var n=p.getViewPort();E[0]=n[0],E[1]=n[1],E[2]=n[2],E[3]=n[3],p.gl.blendFunc(p.gl.SRC_ALPHA,p.gl.ONE_MINUS_SRC_ALPHA),t(),p.currentTextureEffect=P,P.setSourceTexture(T),P.startEffect(),p.setShader(y),p.currentTextureEffect.bind(),p.gl.activeTexture(p.gl.TEXTURE0),p.gl.bindTexture(p.gl.TEXTURE_2D,p.currentTextureEffect.getCurrentSourceTexture().tex),p.currentTextureEffect.finish(),p.setPreviousShader(),h.trigger(),_.set(P.getCurrentSourceTexture()),P.endEffect(),p.setViewPort(E[0],E[1],E[2],E[3]),p.gl.blendFunc(p.gl.SRC_ALPHA,p.gl.ONE_MINUS_SRC_ALPHA),p.currentTextureEffect=null};c.set("clamp to edge"),c.onValueChanged=r,u.set("linear"),u.onValueChanged=o,l.set(!0),a.onTriggered=R,s.set(640),d.set(360),n()},Ops.Gl.TextureEffects.ImageCompose.prototype=new CABLES.Op,Ops.Anim.RelativeTime=function(){function e(){o.set(t.patch.freeTimer.get()*r.get())}Op.apply(this,arguments);var t=this;t.name="RelativeTime";var n=t.inFunction("exe"),r=t.inValue("Multiply",1),o=t.outValue("result");n.onTriggered=e,e()},Ops.Anim.RelativeTime.prototype=new CABLES.Op,Ops.Math.Multiply=function(){function e(){var e=n.get(),t=r.get();isNaN(e)&&(e=0),isNaN(t)&&(t=0),o.set(e*t)}Op.apply(this,arguments);var t=this;t.name="Multiply";var n=t.addInPort(new Port(t,"number1")),r=t.addInPort(new Port(t,"number2")),o=t.addOutPort(new Port(t,"result"));n.onValueChanged=e,r.onValueChanged=e,n.set(1),r.set(2)},Ops.Math.Multiply.prototype=new CABLES.Op,Ops.Gl.TextureEffects.Noise.PerlinNoise=function(){Op.apply(this,arguments);var e=this,t={};t.perlinnoise3d_frag='precision highp float;\n\nuniform float z;\nuniform float x;\nuniform float y;\nuniform float scale;\nIN vec2 texCoord;\nuniform sampler2D tex;\n\nuniform float amount;\n\n{{BLENDCODE}}\n\n\nfloat Interpolation_C2( float x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }   //  6x^5-15x^4+10x^3	( Quintic Curve.  As used by Perlin in Improved Noise.  http://mrl.nyu.edu/~perlin/paper445.pdf )\nvec2 Interpolation_C2( vec2 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec3 Interpolation_C2( vec3 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2( vec4 x ) { return x * x * x * (x * (x * 6.0 - 15.0) + 10.0); }\nvec4 Interpolation_C2_InterpAndDeriv( vec2 x ) { return x.xyxy * x.xyxy * ( x.xyxy * ( x.xyxy * ( x.xyxy * vec2( 6.0, 0.0 ).xxyy + vec2( -15.0, 30.0 ).xxyy ) + vec2( 10.0, -60.0 ).xxyy ) + vec2( 0.0, 30.0 ).xxyy ); }\nvec3 Interpolation_C2_Deriv( vec3 x ) { return x * x * (x * (x * 30.0 - 60.0) + 30.0); }\n\n\nvoid FAST32_hash_3D( 	vec3 gridcell,\n                        out vec4 lowz_hash_0,\n                        out vec4 lowz_hash_1,\n                        out vec4 lowz_hash_2,\n                        out vec4 highz_hash_0,\n                        out vec4 highz_hash_1,\n                        out vec4 highz_hash_2	)		//	generates 3 random numbers for each of the 8 cell corners\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //	TODO: 	these constants need tweaked to find the best possible noise.\n    //			probably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n\n    //	truncate the domain\n    gridcell.xyz = gridcell.xyz - floor(gridcell.xyz * ( 1.0 / DOMAIN )) * DOMAIN;\n    vec3 gridcell_inc1 = step( gridcell, vec3( DOMAIN - 1.5 ) ) * ( gridcell + 1.0 );\n\n    //	calculate the noise\n    vec4 P = vec4( gridcell.xy, gridcell_inc1.xy ) + OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell.zzz * ZINC.xyz ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + gridcell_inc1.zzz * ZINC.xyz ) );\n    lowz_hash_0 = fract( P * lowz_mod.xxxx );\n    highz_hash_0 = fract( P * highz_mod.xxxx );\n    lowz_hash_1 = fract( P * lowz_mod.yyyy );\n    highz_hash_1 = fract( P * highz_mod.yyyy );\n    lowz_hash_2 = fract( P * lowz_mod.zzzz );\n    highz_hash_2 = fract( P * highz_mod.zzzz );\n}\n\n//\n//	Perlin Noise 3D  ( gradient noise )\n//	Return value range of -1.0->1.0\n//	http://briansharpe.files.wordpress.com/2011/11/perlinsample.jpg\n//\nfloat Perlin3D( vec3 P )\n{\n    //	establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n#if 1\n    //\n    //	classic noise.\n    //	requires 3 random values per point.  with an efficent hash function will run faster than improved noise\n    //\n\n    //	calculate the hash.\n    //	( various hashing methods listed in order of speed )\n    vec4 hashx0, hashy0, hashz0, hashx1, hashy1, hashz1;\n    FAST32_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n    //SGPP_hash_3D( Pi, hashx0, hashy0, hashz0, hashx1, hashy1, hashz1 );\n\n    //	calculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n#if 1\n    //	Classic Perlin Interpolation\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    final *= 1.1547005383792515290182975610039;		//	(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/sqrt(0.75)\n    return final;\n#else\n    //	Classic Perlin Surflet\n    //	http://briansharpe.wordpress.com/2012/03/09/modifications-to-classic-perlin-noise/\n    Pf *= Pf;\n    Pf_min1 *= Pf_min1;\n    vec4 vecs_len_sq = vec4( Pf.x, Pf_min1.x, Pf.x, Pf_min1.x ) + vec4( Pf.yy, Pf_min1.yy );\n    float final = dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf.zzzz ) ), grad_results_0 ) + dot( Falloff_Xsq_C2( min( vec4( 1.0 ), vecs_len_sq + Pf_min1.zzzz ) ), grad_results_1 );\n    final *= 2.3703703703703703703703703703704;		//	(optionally) scale things to a strict -1.0->1.0 range    *= 1.0/cube(0.75)\n    return final;\n#endif\n\n#else\n    //\n    //	improved noise.\n    //	requires 1 random value per point.  Will run faster than classic noise if a slow hashing function is used\n    //\n\n    //	calculate the hash.\n    //	( various hashing methods listed in order of speed )\n    vec4 hash_lowz, hash_highz;\n    FAST32_hash_3D( Pi, hash_lowz, hash_highz );\n    //BBS_hash_3D( Pi, hash_lowz, hash_highz );\n    //SGPP_hash_3D( Pi, hash_lowz, hash_highz );\n\n    //\n    //	"improved" noise using 8 corner gradients.  Faster than the 12 mid-edge point method.\n    //	Ken mentions using diagonals like this can cause "clumping", but we\'ll live with that.\n    //	[1,1,1]  [-1,1,1]  [1,-1,1]  [-1,-1,1]\n    //	[1,1,-1] [-1,1,-1] [1,-1,-1] [-1,-1,-1]\n    //\n    hash_lowz -= 0.5;\n    vec4 grad_results_0_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_lowz );\n    hash_lowz = abs( hash_lowz ) - 0.25;\n    vec4 grad_results_0_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_lowz );\n    vec4 grad_results_0_2 = Pf.zzzz * sign( abs( hash_lowz ) - 0.125 );\n    vec4 grad_results_0 = grad_results_0_0 + grad_results_0_1 + grad_results_0_2;\n\n    hash_highz -= 0.5;\n    vec4 grad_results_1_0 = vec2( Pf.x, Pf_min1.x ).xyxy * sign( hash_highz );\n    hash_highz = abs( hash_highz ) - 0.25;\n    vec4 grad_results_1_1 = vec2( Pf.y, Pf_min1.y ).xxyy * sign( hash_highz );\n    vec4 grad_results_1_2 = Pf_min1.zzzz * sign( abs( hash_highz ) - 0.125 );\n    vec4 grad_results_1 = grad_results_1_0 + grad_results_1_1 + grad_results_1_2;\n\n    //	blend the gradients and return\n    vec3 blend = Interpolation_C2( Pf );\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy ) * (2.0 / 3.0);	//	(optionally) mult by (2.0/3.0) to scale to a strict -1.0->1.0 range\n#endif\n}\n\nvoid main()\n{\n    vec4 base=texture2D(tex,texCoord);\n\n   vec2 p=vec2(texCoord.x-0.5,texCoord.y-0.5);\n   p=p*scale;\n\n   p=vec2(p.x+0.5-x,p.y+0.5-y);\n\n    float aa=texture2D(tex,texCoord).r;\n\n   float v=Perlin3D(vec3(p.x,p.y,z))*0.5+0.5;\n   vec4 col=vec4(v,v,v,1.0);\n\n   // col=vec4( _blend(base.rgb,col.rgb) ,amount);\n   col=vec4( _blend(base.rgb,col.rgb) ,1.0);\n   col=vec4( mix( col.rgb, base.rgb ,1.0-base.a*amount),1.0);\n\n   gl_FragColor = col;\n}\n',e.name="PerlinNoise";var n=e.addInPort(new Port(e,"render",OP_PORT_TYPE_FUNCTION)),r=CGL.TextureEffect.AddBlendSelect(e,"Blend Mode","normal"),o=e.inValueSlider("Amount",1),i=e.inValue("X",0),a=e.inValue("Y",0),l=e.inValue("Z",0),s=e.inValue("Scale",22),d=e.addOutPort(new Port(e,"trigger",OP_PORT_TYPE_FUNCTION)),u=e.patch.cgl,c=new CGL.Shader(u),f=t.perlinnoise3d_frag.replace("{{BLENDCODE}}",CGL.TextureEffect.getBlendCode());c.setSource(c.getDefaultVertexShader(),f);new CGL.Uniform(c,"t","tex",0),new CGL.Uniform(c,"f","z",l),new CGL.Uniform(c,"f","x",i),new CGL.Uniform(c,"f","y",a),new CGL.Uniform(c,"f","scale",s),new CGL.Uniform(c,"f","amount",o);r.onChange=function(){CGL.TextureEffect.onChangeBlendSelect(c,r.get())},n.onTriggered=function(){CGL.TextureEffect.checkOpInEffect(e)&&(u.setShader(c),u.currentTextureEffect.bind(),u.gl.activeTexture(u.gl.TEXTURE0),u.gl.bindTexture(u.gl.TEXTURE_2D,u.currentTextureEffect.getCurrentSourceTexture().tex),u.currentTextureEffect.finish(),u.setPreviousShader(),d.trigger())}},Ops.Gl.TextureEffects.Noise.PerlinNoise.prototype=new CABLES.Op,Ops.Gl.Matrix.Transform=function(){function e(){p=!1,(0!==i.get()||0!==a.get()||0!==l.get())&&(p=!0),vec3.set(g,i.get(),a.get(),l.get()),P=!1}function t(){x=!1,0!==s.get()&&(x=!0),vec3.set(h,s.get(),s.get(),s.get()),T=!1}Op.apply(this,arguments);var n=this,r=n.addInPort(new Port(n,"render",OP_PORT_TYPE_FUNCTION)),o=n.addOutPort(new Port(n,"trigger",OP_PORT_TYPE_FUNCTION)),i=n.addInPort(new Port(n,"posX"),0),a=n.addInPort(new Port(n,"posY"),0),l=n.addInPort(new Port(n,"posZ"),0),s=n.addInPort(new Port(n,"scale")),d=n.addInPort(new Port(n,"rotX")),u=n.addInPort(new Port(n,"rotY")),c=n.addInPort(new Port(n,"rotZ")),f=n.patch.cgl,g=vec3.create(),h=vec3.create(),_=mat4.create();mat4.identity(_);var x=!1,p=!1,P=!0,T=!0,m=!0;s.setUiAttribs({divider:!0}),r.onTriggered=function(){var r=!1;P&&(e(),r=!0),T&&(t(),r=!0),m&&(r=!0),r&&v(),f.pushMvMatrix(),mat4.multiply(f.mvMatrix,f.mvMatrix,_),o.trigger(),f.popMvMatrix(),CABLES.UI&&gui.patch().isCurrentOp(n)&&gui.setTransformGizmo({posX:i,posY:a,posZ:l})},n.transform3d=function(){return{pos:[i,a,l]}};var v=function(){mat4.identity(_),p&&mat4.translate(_,_,g),0!==d.get()&&mat4.rotateX(_,_,d.get()*CGL.DEG2RAD),0!==u.get()&&mat4.rotateY(_,_,u.get()*CGL.DEG2RAD),0!==c.get()&&mat4.rotateZ(_,_,c.get()*CGL.DEG2RAD),x&&mat4.scale(_,_,h),m=!1},E=function(){P=!0},T=function(){T=!0},m=function(){m=!0};d.onChange=m,u.onChange=m,c.onChange=m,s.onChange=T,i.onChange=E,a.onChange=E,l.onChange=E,d.set(0),u.set(0),c.set(0),s.set(1),i.set(0),a.set(0),l.set(0),v()},Ops.Gl.Matrix.Transform.prototype=new CABLES.Op,Ops.Gl.Shader.BasicMaterial=function(){function e(){h.get()&&(s.gl.activeTexture(s.gl.TEXTURE0),s.gl.bindTexture(s.gl.TEXTURE_2D,h.get().tex)),r.textureOpacity.get()&&(s.gl.activeTexture(s.gl.TEXTURE1),s.gl.bindTexture(s.gl.TEXTURE_2D,r.textureOpacity.get().tex))}function t(){d&&(s.setShader(d),d.bindTextures(),a.trigger(),s.setPreviousShader())}function n(){v||(v=new CGL.Uniform(d,"f","diffuseRepeatX",p),E=new CGL.Uniform(d,"f","diffuseRepeatY",P),O=new CGL.Uniform(d,"f","texOffsetX",T),C=new CGL.Uniform(d,"f","texOffsetY",m)),v.setValue(p.get()),E.setValue(P.get()),O.setValue(T.get()),C.setValue(m.get())}Op.apply(this,arguments);var r=this,o={};o.shader_frag="{{MODULES_HEAD}}\n\n\n#ifdef HAS_TEXTURES\n    IN vec2 texCoord;\n    IN vec2 texCoordOrig;\n    #ifdef HAS_TEXTURE_DIFFUSE\n        uniform sampler2D tex;\n    #endif\n    #ifdef HAS_TEXTURE_OPACITY\n        uniform sampler2D texOpacity;\n   #endif\n#endif\nuniform float r;\nuniform float g;\nuniform float b;\nuniform float a;\n\nvoid main()\n{\n    {{MODULE_BEGIN_FRAG}}\n    vec4 col=vec4(r,g,b,a);\n    \n    #ifdef HAS_TEXTURES\n        #ifdef HAS_TEXTURE_DIFFUSE\n\n           col=texture2D(tex,vec2(texCoord.x,(1.0-texCoord.y)));\n\n//         col=texture2D(tex,vec2(texCoords.x*1.0,(1.0-texCoords.y)*1.0));\n           #ifdef COLORIZE_TEXTURE\n               col.r*=r;\n               col.g*=g;\n               col.b*=b;\n           #endif\n      #endif\n      col.a*=a;\n      #ifdef HAS_TEXTURE_OPACITY\n      \n            #ifdef TRANSFORMALPHATEXCOORDS\n                col.a*=texture2D(texOpacity,vec2(texCoordOrig.s,1.0-texCoordOrig.t)).g;\n            #endif\n            #ifndef TRANSFORMALPHATEXCOORDS\n                col.a*=texture2D(texOpacity,vec2(texCoord.s,1.0-texCoord.t)).g;\n            #endif\n       #endif\n       \n   #endif\n\n    {{MODULE_COLOR}}\n\n\n   outColor = col;\n}\n",o.shader_vert="{{MODULES_HEAD}}\n\nIN vec3 vPosition;\nIN vec3 attrVertNormal;\nOUT vec3 norm;\nOUT vec2 texCoord;\nOUT vec2 texCoordOrig;\n\n#ifdef HAS_TEXTURES\n    IN vec2 attrTexCoord;\n    #ifdef TEXTURE_REPEAT\n        uniform float diffuseRepeatX;\n        uniform float diffuseRepeatY;\n        uniform float texOffsetX;\n        uniform float texOffsetY;\n\n    #endif\n#endif\n\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\n\nvoid main()\n{\n    mat4 mMatrix=modelMatrix;\n    mat4 mvMatrix;\n    \n    #ifdef HAS_TEXTURES\n        texCoordOrig=attrTexCoord;\n        texCoord=attrTexCoord;\n        #ifdef TEXTURE_REPEAT\n            texCoord.x=texCoord.x*diffuseRepeatX+texOffsetX;\n            texCoord.y=texCoord.y*diffuseRepeatY+texOffsetY;\n        #endif\n   #endif\n\n   vec4 pos = vec4( vPosition, 1. );\n\n\n    #ifdef BILLBOARD\n       vec3 position=vPosition;\n       mvMatrix=viewMatrix*modelMatrix;\n\n       gl_Position = projMatrix * mvMatrix * vec4((\n           position.x * vec3(\n               mvMatrix[0][0],\n               mvMatrix[1][0],\n               mvMatrix[2][0] ) +\n           position.y * vec3(\n               mvMatrix[0][1],\n               mvMatrix[1][1],\n               mvMatrix[2][1]) ), 1.0);\n    #endif\n\n    {{MODULE_VERTEX_POSITION}}\n\n    #ifndef BILLBOARD\n        mvMatrix=viewMatrix * mMatrix;\n    #endif\n\n\n    #ifndef BILLBOARD\n        // gl_Position = projMatrix * viewMatrix * modelMatrix * pos;\n        gl_Position = projMatrix * mvMatrix * pos;\n    #endif\n}\n";var i=r.addInPort(new Port(r,"render",OP_PORT_TYPE_FUNCTION)),a=r.addOutPort(new Port(r,"trigger",OP_PORT_TYPE_FUNCTION)),l=r.addOutPort(new Port(r,"shader",OP_PORT_TYPE_OBJECT));l.ignoreValueSerialize=!0;var s=r.patch.cgl,d=new CGL.Shader(s,"BasicMaterial");d.setModules(["MODULE_VERTEX_POSITION","MODULE_COLOR","MODULE_BEGIN_FRAG"]),d.bindTextures=e,d.setSource(o.shader_vert,o.shader_frag),l.set(d),i.onTriggered=t;var u=r.addInPort(new Port(r,"r",OP_PORT_TYPE_VALUE,{display:"range",colorPick:"true"}));u.set(Math.random()),u.uniform=new CGL.Uniform(d,"f","r",u);var c=r.addInPort(new Port(r,"g",OP_PORT_TYPE_VALUE,{display:"range"}));c.set(Math.random()),c.uniform=new CGL.Uniform(d,"f","g",c);var f=r.addInPort(new Port(r,"b",OP_PORT_TYPE_VALUE,{display:"range"}));f.set(Math.random()),u.uniform=new CGL.Uniform(d,"f","b",f);var g=r.addInPort(new Port(r,"a",OP_PORT_TYPE_VALUE,{display:"range"}));g.uniform=new CGL.Uniform(d,"f","a",g),g.set(1);var h=this.addInPort(new Port(this,"texture",OP_PORT_TYPE_TEXTURE,{preview:!0,display:"createOpHelper"})),_=null;d.bindTextures=e,h.onChange=function(){h.get()?(d.hasDefine("HAS_TEXTURE_DIFFUSE")||d.define("HAS_TEXTURE_DIFFUSE"),_||(_=new CGL.Uniform(d,"t","texDiffuse",0)),n()):(d.removeUniform("texDiffuse"),d.removeDefine("HAS_TEXTURE_DIFFUSE"),_=null)},r.textureOpacity=r.addInPort(new Port(r,"textureOpacity",OP_PORT_TYPE_TEXTURE,{preview:!0,display:"createOpHelper"})),r.textureOpacityUniform=null,r.textureOpacity.onChange=function(){if(r.textureOpacity.get()){if(null!==r.textureOpacityUniform)return;d.removeUniform("texOpacity"),d.define("HAS_TEXTURE_OPACITY"),r.textureOpacityUniform||(r.textureOpacityUniform=new CGL.Uniform(d,"t","texOpacity",1))}else d.removeUniform("texOpacity"),d.removeDefine("HAS_TEXTURE_OPACITY"),r.textureOpacityUniform=null},r.colorizeTexture=r.addInPort(new Port(r,"colorizeTexture",OP_PORT_TYPE_VALUE,{display:"bool"})),r.colorizeTexture.set(!1),r.colorizeTexture.onChange=function(){r.colorizeTexture.get()?d.define("COLORIZE_TEXTURE"):d.removeDefine("COLORIZE_TEXTURE")},r.doBillboard=r.addInPort(new Port(r,"billboard",OP_PORT_TYPE_VALUE,{display:"bool"})),r.doBillboard.set(!1),r.doBillboard.onChange=function(){r.doBillboard.get()?d.define("BILLBOARD"):d.removeDefine("BILLBOARD")};var x=r.inValueBool("Opacity TexCoords Transform",!1);x.onChange=function(){x.get()?d.define("TRANSFORMALPHATEXCOORDS"):d.removeDefine("TRANSFORMALPHATEXCOORDS")};var p=(r.addInPort(new Port(r,"preMultiplied alpha",OP_PORT_TYPE_VALUE,{display:"bool"})),r.addInPort(new Port(r,"diffuseRepeatX",OP_PORT_TYPE_VALUE))),P=r.addInPort(new Port(r,"diffuseRepeatY",OP_PORT_TYPE_VALUE)),T=r.addInPort(new Port(r,"Tex Offset X",OP_PORT_TYPE_VALUE)),m=r.addInPort(new Port(r,"Tex Offset Y",OP_PORT_TYPE_VALUE));p.onChange=n,P.onChange=n,m.onChange=n,T.onChange=n;var v=null,E=null,O=null,C=null;d.define("TEXTURE_REPEAT"),T.set(0),m.set(0),p.set(1),P.set(1)},Ops.Gl.Shader.BasicMaterial.prototype=new CABLES.Op,Ops.Gl.Meshes.Circle=function(){function e(){var e=Math.max(3,Math.floor(r.get()));_.clear();var t=[],n=[],d=[],g=0,h=0,P=0,T=0,m=0,v=0,E=0,O=0,C=0,y=0,L=0,w=0,R=0,I=0,A=0,S=0,M=[];if(f.get()){var U=0,z=0,D=[];for(g=0;g<=e*a.get();g++)h=360/e*g*CGL.DEG2RAD,A=Math.cos(h)*o.get(),S=Math.sin(h)*o.get(),I=.5,g>0&&(M.push(U),M.push(z),M.push(0),R=1-(g-1)/e,D.push(R,I)),M.push(A),M.push(S),M.push(0),R=1-g/e,D.push(R,I),U=A,z=S;_.setPointVertices(M),_.texCoords=D}else if(i.get()<=0){for(g=0;g<=e*a.get();g++)h=360/e*g*CGL.DEG2RAD,A=Math.cos(h)*o.get(),S=Math.sin(h)*o.get(),"flat"==p.get()?(R=(Math.cos(h)+1)/2,I=1-(Math.sin(h)+1)/2,L=.5,w=.5):"round"==p.get()&&(R=1-g/e,I=0,L=R,w=1),t.push([A,S,0],[P,T,0],[0,0,0]),n.push(R,I,m,v,L,w),d.push(0,0,1,0,0,1,0,0,1),m=R,v=I,P=A,T=S;_=CGL.Geometry.buildFromFaces(t),_.vertexNormals=d,_.texCoords=n}else{var G=0,V=e*a.get();for(g=0;V>=g;g++){G++,h=360/e*g*CGL.DEG2RAD,A=Math.cos(h)*o.get(),S=Math.sin(h)*o.get();var b=Math.cos(h)*i.get()*o.get(),F=Math.sin(h)*i.get()*o.get();"flat"==p.get()?(R=(Math.cos(h)+1)/2,I=1-(Math.sin(h)+1)/2,L=(R-.5)*i.get()+.5,w=(I-.5)*i.get()+.5):"round"==p.get()&&(R=1-g/e,I=0,L=R,w=1),(0===l.get()||G%parseInt(l.get(),10)===0&&!s.get()||G%parseInt(l.get(),10)!==0&&s.get())&&(t.push([A,S,0],[P,T,0],[b,F,0]),t.push([b,F,0],[P,T,0],[E,O,0]),n.push(R,0,m,0,L,1),n.push(R,1,m,0,C,1),d.push(0,0,1,0,0,1,0,0,1),d.push(0,0,1,0,0,1,0,0,1)),C=L,y=w,m=R,v=I,P=A,T=S,E=b,O=F}_=CGL.Geometry.buildFromFaces(t),_.vertexNormals=d,_.texCoords=n}u.set(null),u.set(_),0!=_.vertices.length&&(x||(x=new CGL.Mesh(c,_)),x.setGeom(_))}Op.apply(this,arguments);var t=this,n=t.inFunction("render"),r=t.inValue("segments",40),o=t.inValue("radius",1),i=t.inValueSlider("innerRadius",0),a=t.inValueSlider("percent"),l=t.inValue("steps",0),s=t.inValueBool("invertSteps",!1),d=t.outFunction("trigger"),u=t.addOutPort(new Port(t,"geometry",OP_PORT_TYPE_OBJECT));u.ignoreValueSerialize=!0;var c=t.patch.cgl,f=t.addInPort(new Port(t,"Spline",OP_PORT_TYPE_VALUE,{display:"bool"}));f.set(!1);var g=0,h=null;n.onTriggered=function(){t.instanced(n)||(h=c.getShader(),h&&(g=h.glPrimitive,f.get()&&(h.glPrimitive=c.gl.LINE_STRIP),x.render(h),d.trigger(),h.glPrimitive=g))},a.set(1);var _=new CGL.Geometry("circle"),x=null,p=t.addInPort(new Port(t,"mapping",OP_PORT_TYPE_VALUE,{display:"dropdown",values:["flat","round"]}));p.set("flat"),p.onValueChange(e),r.onChange=e,o.onChange=e,i.onChange=e,a.onChange=e,l.onChange=e,s.onChange=e,f.onChange=e,e()},Ops.Gl.Meshes.Circle.prototype=new CABLES.Op,Ops.Gl.ShaderEffects.VertexDisplacementMap=function(){function e(){m&&(h.get()?m.define(a+"HEIGHTMAP_COLORIZE"):m.removeDefine(a+"HEIGHTMAP_COLORIZE"))}function t(){m&&(c.get()?m.define(a+"HEIGHTMAP_INVERT"):m.removeDefine(a+"HEIGHTMAP_INVERT"))}function n(){m&&(u.get()?m.define(a+"DISPLACE_REMOVE_ZERO"):m.removeDefine(a+"DISPLACE_REMOVE_ZERO"))}function r(){m&&y&&m.removeModule(y),m&&L&&m.removeModule(L),m=null}Op.apply(this,arguments);var o=this,i=o.patch.cgl,a="mod"+Math.floor(1e4*Math.random());o.name="VertexDisplacement",o.render=o.addInPort(new Port(this,"render",OP_PORT_TYPE_FUNCTION)),o.trigger=o.addOutPort(new Port(this,"trigger",OP_PORT_TYPE_FUNCTION));var l=this.addInPort(new Port(this,"texture",OP_PORT_TYPE_TEXTURE)),s=o.inValue("extrude",.5),d=o.inValueBool("flip",!0),u=o.addInPort(new Port(this,"Ignore Zero Values",OP_PORT_TYPE_VALUE,{display:"bool"})),c=o.addInPort(new Port(this,"invert",OP_PORT_TYPE_VALUE,{display:"bool"}));c.set(!1);var f=o.addInPort(new Port(this,"offset X",OP_PORT_TYPE_VALUE)),g=o.addInPort(new Port(this,"offset Y",OP_PORT_TYPE_VALUE)),h=o.addInPort(new Port(this,"colorize",OP_PORT_TYPE_VALUE,{display:"bool"})),_=o.addInPort(new Port(this,"colorize add",OP_PORT_TYPE_VALUE,{display:"range"}));h.set(!1),h.onValueChanged=e,c.onValueChanged=t;var x=o.addInPort(new Port(this,"mode",OP_PORT_TYPE_VALUE,{display:"dropdown",values:["mul xyz","add z","add y","mul y","sub z"]}));u.onValueChanged=n;var p=function(){m&&(d.get()?m.define(a+"FLIPY"):m.removeDefine(a+"FLIPY"),m.removeDefine(a+"DISPLACE_METH_MULXYZ"),m.removeDefine(a+"DISPLACE_METH_ADDZ"),m.removeDefine(a+"DISPLACE_METH_ADDY"),"mul xyz"==x.get()&&m.define(a+"DISPLACE_METH_MULXYZ"),"add z"==x.get()&&m.define(a+"DISPLACE_METH_ADDZ"),"add y"==x.get()&&m.define(a+"DISPLACE_METH_ADDY"),"mul y"==x.get()&&m.define(a+"DISPLACE_METH_MULY"),n())};d.onValueChanged=p,x.onValueChanged=p,x.set("mul xyz");var P,T,m=null,v="".endl()+"UNI float {{mod}}_extrude;".endl()+"UNI sampler2D {{mod}}_texture;".endl()+"UNI float {{mod}}_offsetX;".endl()+"UNI float {{mod}}_offsetY;".endl()+"OUT float "+a+"displHeightMapColor;".endl(),E="".endl()+"vec2 {{mod}}tc=texCoord;".endl()+"#ifdef "+a+"FLIPY".endl()+"    {{mod}}tc.y=1.0-{{mod}}tc.y;".endl()+"#endif".endl()+"float {{mod}}_texVal=texture2D( {{mod}}_texture, vec2({{mod}}tc.x+{{mod}}_offsetX,{{mod}}tc.y+{{mod}}_offsetY) ).b;".endl()+"#ifdef "+a+"HEIGHTMAP_INVERT".endl()+"{{mod}}_texVal=1.0-{{mod}}_texVal;".endl()+"#endif".endl()+"#ifdef "+a+"DISPLACE_METH_MULXYZ".endl()+"   {{mod}}_texVal+=1.0;".endl()+"   pos.xyz *= {{mod}}_texVal * {{mod}}_extrude;".endl()+"#endif".endl()+"#ifdef "+a+"DISPLACE_METH_ADDZ".endl()+"   pos.z+=({{mod}}_texVal * {{mod}}_extrude);".endl()+"#endif".endl()+"#ifdef "+a+"DISPLACE_METH_ADDY".endl()+"   pos.y+=({{mod}}_texVal * {{mod}}_extrude);".endl()+"#endif".endl()+"#ifdef "+a+"DISPLACE_METH_MULY".endl()+"   pos.y+=(({{mod}}_texVal-0.5) * {{mod}}_extrude);".endl()+"#endif".endl()+a+"displHeightMapColor={{mod}}_texVal;".endl(),O="".endl()+"UNI float {{mod}}_colorizeAdd;".endl()+"IN float "+a+"displHeightMapColor;".endl()+"UNI sampler2D {{mod}}_texture;".endl(),C="".endl()+"#ifdef "+a+"HEIGHTMAP_COLORIZE".endl()+"   col.rgb*="+a+"displHeightMapColor*(1.0-{{mod}}_colorizeAdd);".endl()+"   col+={{mod}}_colorizeAdd;".endl()+"#endif".endl()+"#ifdef "+a+"DISPLACE_REMOVE_ZERO".endl()+"if("+a+"displHeightMapColor==0.0)discard;".endl()+"#endif".endl(),y=null,L=null,T=null,w=null,P=null,R=null,I=null,A=null;o.render.onLinkChanged=r,o.render.onTriggered=function(){if(!i.getShader())return void o.trigger.trigger();if(i.getShader()!=m&&(m&&r(),m=i.getShader(),L=m.addModule({title:o.objName,name:"MODULE_VERTEX_POSITION",srcHeadVert:v,srcBodyVert:E}),T=new CGL.Uniform(m,"t",L.prefix+"_texture",0),P=new CGL.Uniform(m,"f",L.prefix+"_extrude",s),R=new CGL.Uniform(m,"f",L.prefix+"_offsetX",f),I=new CGL.Uniform(m,"f",L.prefix+"_offsetY",g),y=m.addModule({title:o.objName,name:"MODULE_COLOR",srcHeadFrag:O,srcBodyFrag:C}),w=new CGL.Uniform(m,"t",y.prefix+"_texture",0),A=new CGL.Uniform(m,"f",y.prefix+"_colorizeAdd",_),p(),t(),e()),m){var n=L.num+5;l.get()&&(T.setValue(n),w.setValue(n),i.gl.activeTexture(i.gl.TEXTURE0+n),i.gl.bindTexture(i.gl.TEXTURE_2D,l.get().tex)),o.trigger.trigger()}}},Ops.Gl.ShaderEffects.VertexDisplacementMap.prototype=new CABLES.Op,Ops.Gl.MainLoop=function(){function e(){function e(){_&&(_.style.display="block")}function n(){_&&(_.style.display="none")}if(t.patch.cgl.canvas.addEventListener("mouseleave",n),t.patch.cgl.canvas.addEventListener("mouseenter",e),l.get()){if(!_){_=document.createElement("div");var r=t.patch.cgl.canvas.parentElement;r&&r.appendChild(_),_.addEventListener("mouseenter",e),_.addEventListener("click",function(e){CABLES.UI&&!e.shiftKey?gui.cycleRendererSize():u.fullScreen()})}_.style.padding="10px",_.style.position="absolute",_.style.right="5px",_.style.top="5px",_.style.width="20px",_.style.height="20px",_.style.cursor="pointer",_.style["border-radius"]="40px",_.style.background="#444",_.style["z-index"]="9999",_.style.display="none",_.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Capa_1" x="0px" y="0px" viewBox="0 0 490 490" style="width:20px;height:20px;" xml:space="preserve" width="512px" height="512px"><g><path d="M173.792,301.792L21.333,454.251v-80.917c0-5.891-4.776-10.667-10.667-10.667C4.776,362.667,0,367.442,0,373.333V480     c0,5.891,4.776,10.667,10.667,10.667h106.667c5.891,0,10.667-4.776,10.667-10.667s-4.776-10.667-10.667-10.667H36.416     l152.459-152.459c4.093-4.237,3.975-10.99-0.262-15.083C184.479,297.799,177.926,297.799,173.792,301.792z" fill="#FFFFFF"/><path d="M480,0H373.333c-5.891,0-10.667,4.776-10.667,10.667c0,5.891,4.776,10.667,10.667,10.667h80.917L301.792,173.792     c-4.237,4.093-4.354,10.845-0.262,15.083c4.093,4.237,10.845,4.354,15.083,0.262c0.089-0.086,0.176-0.173,0.262-0.262     L469.333,36.416v80.917c0,5.891,4.776,10.667,10.667,10.667s10.667-4.776,10.667-10.667V10.667C490.667,4.776,485.891,0,480,0z" fill="#FFFFFF"/><path d="M36.416,21.333h80.917c5.891,0,10.667-4.776,10.667-10.667C128,4.776,123.224,0,117.333,0H10.667     C4.776,0,0,4.776,0,10.667v106.667C0,123.224,4.776,128,10.667,128c5.891,0,10.667-4.776,10.667-10.667V36.416l152.459,152.459     c4.237,4.093,10.99,3.975,15.083-0.262c3.992-4.134,3.992-10.687,0-14.82L36.416,21.333z" fill="#FFFFFF"/><path d="M480,362.667c-5.891,0-10.667,4.776-10.667,10.667v80.917L316.875,301.792c-4.237-4.093-10.99-3.976-15.083,0.261     c-3.993,4.134-3.993,10.688,0,14.821l152.459,152.459h-80.917c-5.891,0-10.667,4.776-10.667,10.667s4.776,10.667,10.667,10.667     H480c5.891,0,10.667-4.776,10.667-10.667V373.333C490.667,367.442,485.891,362.667,480,362.667z" fill="#FFFFFF"/></g></svg>'}else _&&(_.style.display="none",_.remove(),_=null)}Op.apply(this,arguments);var t=this,n=t.inValue("FPS Limit",0),r=t.outFunction("trigger"),o=t.outValue("width"),i=t.outValue("height"),a=(t.inValueBool("Reduce FPS loading"),t.inValueBool("Clear",!0)),l=t.inValueBool("Fullscreen Button",!1),s=t.inValueBool("Active",!0),d=t.inValueBool("Hires Displays",!1);d.onChange=function(){d.get()?t.patch.cgl.pixelDensity=window.devicePixelRatio:t.patch.cgl.pixelDensity=1,t.patch.cgl.updateSize(),CABLES.UI&&gui.setLayout()};var u=t.patch.cgl,c=0,f=0;t.patch.cgl||t.uiAttr({error:"No webgl cgl context"});var g=vec3.create();vec3.set(g,0,0,0);var h=vec3.create();vec3.set(h,0,0,-2),l.onChange=e,setTimeout(e,100);var _=null;n.onChange=function(){t.patch.config.fpsLimit=n.get()||0},t.onDelete=function(){u.gl.clearColor(0,0,0,0),u.gl.clear(u.gl.COLOR_BUFFER_BIT|u.gl.DEPTH_BUFFER_BIT),t.patch.removeOnAnimFrame(t)},t.patch.loading.setOnFinishedLoading(function(e){t.patch.config.fpsLimit=n.get()}),t.onAnimFrame=function(e){if(s.get()&&!u.aborted&&0!==u.canvas.clientWidth&&0!==u.canvas.clientHeight){if(t.patch.loading.getProgress()<1&&(t.patch.config.fpsLimit=5),-1==u.canvasWidth)return void u.setCanvas(t.patch.config.glCanvasId);(u.canvasWidth!=o.get()||u.canvasHeight!=i.get())&&(o.set(u.canvasWidth),i.set(u.canvasHeight)),CABLES.now()-f>1e3&&(CGL.fpsReport=CGL.fpsReport||[],
t.patch.loading.getProgress()>=1&&0!==f&&CGL.fpsReport.push(c),c=0,f=CABLES.now()),CGL.MESH.lastShader=null,CGL.MESH.lastMesh=null,u.renderStart(u,g,h),a.get()&&(u.gl.clearColor(0,0,0,1),u.gl.clear(u.gl.COLOR_BUFFER_BIT|u.gl.DEPTH_BUFFER_BIT)),r.trigger(),CGL.MESH.lastMesh&&CGL.MESH.lastMesh.unBind(),CGL.Texture.previewTexture&&(CGL.Texture.texturePreviewer||(CGL.Texture.texturePreviewer=new CGL.Texture.texturePreview(u)),CGL.Texture.texturePreviewer.render(CGL.Texture.previewTexture)),u.renderEnd(u),u.frameStore.phong||(u.frameStore.phong={}),c++}}},Ops.Gl.MainLoop.prototype=new CABLES.Op,Ops.Deprecated.Value=function(){Op.apply(this,arguments);var e=this;e.name="Value";var t=e.addInPort(new Port(e,"exe",OP_PORT_TYPE_FUNCTION)),n=e.addInPort(new Port(e,"value",OP_PORT_TYPE_VALUE)),r=e.addOutPort(new Port(e,"result")),o=function(){r.set(n.get())};t.onTriggered=o,n.onValueChanged=o},Ops.Deprecated.Value.prototype=new CABLES.Op,Ops.Gl.TextureEffects.Plasma=function(){Op.apply(this,arguments);var e=this;e.name="Plasma";var t=e.addInPort(new Port(e,"render",OP_PORT_TYPE_FUNCTION)),n=CGL.TextureEffect.AddBlendSelect(e,"Blend Mode","normal"),r=e.inValueSlider("Amount",1),o=e.inValue("Width",20),i=e.inValue("Height",20),a=e.inValue("Mul",1),l=e.inValue("Time",1),s=e.addOutPort(new Port(e,"trigger",OP_PORT_TYPE_FUNCTION)),d="".endl()+"precision mediump float;".endl()+"#define PI 3.1415926535897932384626433832795".endl()+"uniform float time;".endl()+"uniform float w;".endl()+"uniform float h;".endl()+"uniform float mul;".endl()+"uniform float amount;".endl()+"uniform sampler2D tex;".endl()+"IN vec2 texCoord;"+CGL.TextureEffect.getBlendCode().endl()+"void main() {".endl()+"   vec2 size=vec2(w,h);".endl()+"    float v = 0.0;".endl()+"    vec2 c = texCoord * size - size/2.0;".endl()+"    v += sin((c.x+time));".endl()+"    v += sin((c.y+time)/2.0);".endl()+"    v += sin((c.x+c.y+time)/2.0);".endl()+"    c += size/2.0 * vec2(sin(time/3.0), cos(time/2.0));".endl()+"    v += sin(sqrt(c.x*c.x+c.y*c.y+1.0)+time);".endl()+"    v = v/2.0;".endl()+"    vec3 newColor = vec3(sin(PI*v*mul/4.0), sin(PI*v*mul), cos(PI*v*mul))*.5 + .5;".endl()+"   vec4 base=texture2D(tex,texCoord);".endl()+"   vec4 col=vec4( _blend(base.rgb,newColor) ,1.0);".endl()+"   col=vec4( mix( col.rgb, base.rgb ,1.0-base.a*amount),1.0);".endl()+"    gl_FragColor = col;".endl()+"}",u=e.patch.cgl,c=new CGL.Shader(u);c.setSource(c.getDefaultVertexShader(),d);new CGL.Uniform(c,"t","tex",0),new CGL.Uniform(c,"f","w",o),new CGL.Uniform(c,"f","h",i),new CGL.Uniform(c,"f","time",l),new CGL.Uniform(c,"f","mul",a),new CGL.Uniform(c,"t","tex",0),new CGL.Uniform(c,"f","amount",r);t.onTriggered=function(){u.currentTextureEffect&&(u.setShader(c),u.currentTextureEffect.bind(),u.gl.activeTexture(u.gl.TEXTURE0),u.gl.bindTexture(u.gl.TEXTURE_2D,u.currentTextureEffect.getCurrentSourceTexture().tex),u.currentTextureEffect.finish(),u.setPreviousShader(),s.trigger())},n.onValueChanged=function(){CGL.TextureEffect.onChangeBlendSelect(c,n.get())}},Ops.Gl.TextureEffects.Plasma.prototype=new CABLES.Op;